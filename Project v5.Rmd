---
title: "Project"
author: "Warren Speth and Jeff"
date: "March 3, 2019"
output: html_document
---
#making changes
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(caret)
library(data.table)
library(glmnet)
library(rpart)
library(rpart.plot)
library(randomForest)
library(xgboost)
library(gbm)
library(class)
library(pvclass)
library(knnGarden)

log_prob <- function(pred){
  1/(1+exp(-pred))
}
```


```{r}
df <- read.csv("bank_additional_full.csv")

levels(df$job)[2] <- "bluecollar"
levels(df$job)[7] <- "selfemployed"


df <- as.data.table(model.matrix(~.-1,df))
# colnames(df)[colnames(df)=="ytrue"] <- "outcome"
df$Class <- ifelse(df$ytrue==1,TRUE,FALSE)
```

```{r}
# 
# summary(df)
# str(df)
# table(df$campaign)
# 
# barplot(table(df$Class,df$campaign)[2,1:15]/(table(df$Class,df$campaign)[1,1:15]+table(df$Class,df$campaign)[2,1:15]))

summary(df$Class)
NROW(df$Class[df$Class=='TRUE'])/NROW(df$Class)
```


```{r}
df[,ID := .I]

#split into test and train
set.seed(99)
training_size <- floor(0.80 * nrow(df))
train_ind <- sample(seq_len(nrow(df)), size = training_size)

df_train <- df[train_ind, ]

df_test <- df[-train_ind, ]
df_test[df_test$campaign>5,'Class']<-FALSE
df_test$campaign[df_test$campaign>5]<-5
df_test[,campaign2 := ifelse(campaign == 2, 1,0)]
df_test[,campaign3 := ifelse(campaign == 3, 1,0)]
df_test[,campaign4 := ifelse(campaign == 4, 1,0)]
df_test[,campaign5 := ifelse(campaign == 5, 1,0)]

# Work on training data
full_df <- df_train[rep(1:.N,campaign)][,campaign_no:=1:.N,by=ID]
full_df[campaign != campaign_no,'Class'] <- FALSE
full_df[,campaign2 := ifelse(campaign_no == 2, 1,0)]
full_df[,campaign3 := ifelse(campaign_no == 3, 1,0)]
full_df[,campaign4 := ifelse(campaign_no == 4, 1,0)]
full_df[,campaign5 := ifelse(campaign_no == 5, 1,0)]
model_df<-full_df[campaign_no<=5,c(56,1:30,47:49, 59:62)]
x_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5+campaign2+campaign3+campaign4+campaign5-1,data=model_df)

```

```{r}
# foldid=sample(1:10,size=length(model_df$Class),replace=TRUE)
# cv_ridge <- cv.glmnet(x=x_matrix, y=model_df$Class, foldid=foldid, lambda = exp(seq(from = -10, to = 0, by = .1)), family="binomial",alpha=0)
# cv_enet <- cv.glmnet(x=x_matrix, y=model_df$Class, foldid=foldid, lambda = exp(seq(from = -10, to = 0, by = .1)), family="binomial",alpha=.5)
# cv_lasso <- cv.glmnet(x=x_matrix, y=model_df$Class, foldid=foldid, lambda = exp(seq(from = -10, to = 0, by = .1)), family="binomial",alpha=1)
# 
# save(cv_ridge, file="cv_ridge.rda")
# save(cv_lasso, file="cv_lasso.rda")
# save(cv_enet, file="cv_enet.rda")

load(file="cv_ridge.rda")
load(file="cv_lasso.rda")
load(file="cv_enet.rda")

plot(log(cv_lasso$lambda),cv_lasso$cvm,pch=19,col="red",xlab="log(Lambda)",ylab=cv_lasso$name)
points(log(cv_enet$lambda),cv_enet$cvm,pch=19,col="grey")
points(log(cv_ridge$lambda),cv_ridge$cvm,pch=19,col="blue")
legend("topleft",legend=c("alpha= 1","alpha= .5","alpha 0"),pch=19,col=c("red","grey","blue"))

lasso_coefficients <- predict(cv_lasso,type="coefficients")
```

```{r}
# test_reg   <-glm(Class~(age+jobadmin.+jobbluecollar+jobentrepreneur+jobhousemaid+jobmanagement+jobretired+jobselfemployed+jobservices+jobstudent+jobtechnician+jobunemployed+jobunknown) *( campaign2+campaign3)+campaign4+campaign5+maritalsingle+maritalunknown+educationbasic.6y+educationbasic.9y+educationhigh.school+educationilliterate+educationprofessional.course+educationuniversity.degree+educationunknown+defaultunknown+defaultyes+housingunknown+housingyes+loanunknown+loanyes,family='binomial',data=model_df)
# save(test_reg, file="test_reg.rda")

load(file="test_reg.rda")
```

```{r}
#ASSUMPTIONS:

          wage <-12 #Estimate of hourly wage 
          fail_time <-mean(df$duration[df$Class=="FALSE"]) / 3600
          success_time <-mean(df$duration[df$Class=="TRUE"]) / 3600
          Inter_call_time <-1/60
          fail_cost<-wage*(fail_time+Inter_call_time)
          success_cost <-wage*(success_time+Inter_call_time)
          
  #Output: [cost of failure], [cost of success/signup]
#Profit from successful customer: According to a paper, CD rates in the Netherlands average ~60% of Euribor rates (https://onlinelibrary.wiley.com/doi/full/10.1111/irfi.12143)
          Market_rate <-.025 
          CD_rate <-Market_rate*.6
          Balance<-10000 #(simply assumed)
          Term <- .25 #(.25 years, assumed based on rate)
          Revenue <- Balance*Term*(Market_rate-CD_rate)  #(roughly a function of not having to borrow this money at market rates, flat curve assumed)
          Success_profit <-Revenue - success_cost

```

```{r}
#Generate estimates of cost per call, benefit (revenue/profit) of time deposit product for bank

        #Cost- Relevant inputs: hourly wage, average call information (separate averages for failures and successes          b/c they have drastically different lengths)

Compute_Sample_Profitability<-function(obs){
          sample_person <-df_test[obs]
          
    #from regression coefficients + person's info: Simple prediction of success likelihood on the nth call "prob(n)" (conditional on failures for all previous calls)

#Loops through prediction turning on campaigns to calculate probabilities of success on calls 1:5
prob <-rep(NA,5)
    sample_person$campaign2<-0
    sample_person$campaign3<-0
    sample_person$campaign4<-0
    sample_person$campaign5<-0
prob[1] <-log_prob(predict(test_reg,sample_person))
    sample_person$campaign2<-1
prob[2] <-log_prob(predict(test_reg,sample_person))
    sample_person$campaign2<-0
    sample_person$campaign3<-1
prob[3] <-log_prob(predict(test_reg,sample_person))
    sample_person$campaign3<-0
    sample_person$campaign4<-1
prob[4] <-log_prob(predict(test_reg,sample_person))
    sample_person$campaign4<-0
    sample_person$campaign5<-1
prob[5] <-log_prob(predict(test_reg,sample_person))
    sample_person$campaign5<-0


    #For Calls 1 through N, compute likelihood of success by the nth call: p_sub(n)
        
p_sub<-rep(NA,5)
  p_sub[1]<-prob[1]
  for (i in 2:5) {
    p_sub[i] <-p_sub[i-1]+prob[i]*(1-p_sub[i-1])
  }

  
  #For calls 1 through N, compute lift of call n: lift(n)= p_sub(n) - p_sub(n-1) (this represents unconditional probability of success on call n)
lift<-rep(NA,5)
  lift[1]<-p_sub[1]
  for (i in 2:5) {
    lift[i] <-p_sub[i]-p_sub[i-1]
  }
  
#Compute number of calls to target for a given customer (N.B.: As long as probability of success is declining monotonically, as soon as the nth call is not profitable, the (n+1)th call will also not be profitable.) 
  #Test: Identify whether the nth call (if made) would be profitable. THis is simple:
   #Profit(n|All calls prior="no")=[Profit of Success]*p_sub(n) -[Cost of Failure]*(1-p_sub(n)) 
  Profit <- rep(NA,5)
  for (i in 1:5){
    Profit[i] <- Success_profit*prob[i]-fail_cost*(1-prob[i])
  }
  #Decision: for the first unprofitable call "A," choose  A-1 as the target number of calls.
  Calls_to_make<-0
  Calls_to_make <-NROW(Profit[Profit>0])
  #based out this decision (target customer with A-1 calls), also compute 
    #(1) the expected number of calls with that rule(this is not simply A-1 b/c customer may sign up earlier), and
Expected_calls <- 0
if(Calls_to_make<=1) {
  Expected_calls<-Calls_to_make
}  else {
    for (i in 1:(Calls_to_make-1)){
      Expected_calls<-Expected_calls+i*lift[i]
    }
    Expected_calls<-Expected_calls+Calls_to_make*(1-p_sub[Calls_to_make-1])
  }

    #(2) the expected profit from this strategy (weighted average of profitabilities forscenarios given this targeting plan, weighting each scenario by lift(n) and then adding together)
  
  
  Expected_profit <- 0
  if (Calls_to_make>0){
    for (i in 1:Calls_to_make){
      Expected_profit <-Expected_profit+lift[i]*(Success_profit-fail_cost*(i-1))
    }
    Expected_profit <-Expected_profit-fail_cost*Calls_to_make*(1-p_sub[Calls_to_make])
  } 

  Metrics <-c("Euribor","Max Calls","Expected Calls", "Profit")
  values<-c(Market_rate,Calls_to_make,Expected_calls,Expected_profit)
  results <-data.frame(Metrics,values)
#  print(results)
  
  return_frame <- data.frame(max_calls = Calls_to_make, p1 = prob[1], p2 = prob[2], p3 = prob[3], p4 = prob[4], p5 = prob[5])
  
  return(return_frame)

}

```

```{r}
#Generate estimates of cost per call, benefit (revenue/profit) of time deposit product for bank

        #Cost- Relevant inputs: hourly wage, average call information (separate averages for failures and successes          b/c they have drastically different lengths)

Compute_Sample_Profitability_LASSO<-function(obs,model){
          sample_person <-df_test[obs]

#Loops through prediction turning on campaigns to calculate probabilities of success on calls 1:5
prob <-rep(NA,5)
    sample_person$campaign2<-0
    sample_person$campaign3<-0
    sample_person$campaign4<-0
    sample_person$campaign5<-0
    lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
    test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5+campaign2+campaign3+campaign4+campaign5-1,data=lasso_test)
prob[1] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
    sample_person$campaign2<-1
    lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
    test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5+campaign2+campaign3+campaign4+campaign5-1,data=lasso_test)
prob[2] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
    sample_person$campaign2<-0
    sample_person$campaign3<-1
    lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
    test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5+campaign2+campaign3+campaign4+campaign5-1,data=lasso_test)
prob[3] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
    sample_person$campaign3<-0
    sample_person$campaign4<-1
    lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
    test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5+campaign2+campaign3+campaign4+campaign5-1,data=lasso_test)
prob[4] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
    sample_person$campaign4<-0
    sample_person$campaign5<-1
    lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
    test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5+campaign2+campaign3+campaign4+campaign5-1,data=lasso_test)
prob[5] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))


    #For Calls 1 through N, compute likelihood of success by the nth call: p_sub(n)
        
p_sub<-rep(NA,5)
  p_sub[1]<-prob[1]
  for (i in 2:5) {
    p_sub[i] <-p_sub[i-1]+prob[i]*(1-p_sub[i-1])
  }

  
  #For calls 1 through N, compute lift of call n: lift(n)= p_sub(n) - p_sub(n-1) (this represents unconditional probability of success on call n)
lift<-rep(NA,5)
  lift[1]<-p_sub[1]
  for (i in 2:5) {
    lift[i] <-p_sub[i]-p_sub[i-1]
  }
  
#Compute number of calls to target for a given customer (N.B.: As long as probability of success is declining monotonically, as soon as the nth call is not profitable, the (n+1)th call will also not be profitable.) 
  #Test: Identify whether the nth call (if made) would be profitable. THis is simple:
   #Profit(n|All calls prior="no")=[Profit of Success]*p_sub(n) -[Cost of Failure]*(1-p_sub(n)) 
  Profit <- rep(NA,5)
  for (i in 1:5){
    Profit[i] <- Success_profit*prob[i]-fail_cost*(1-prob[i])
  }
  #Decision: for the first unprofitable call "A," choose  A-1 as the target number of calls.
  Calls_to_make<-0
  Calls_to_make <-NROW(Profit[Profit>0])
  #based out this decision (target customer with A-1 calls), also compute 
    #(1) the expected number of calls with that rule(this is not simply A-1 b/c customer may sign up earlier), and
Expected_calls <- 0
if(Calls_to_make<=1) {
  Expected_calls<-Calls_to_make
}  else {
    for (i in 1:(Calls_to_make-1)){
      Expected_calls<-Expected_calls+i*lift[i]
    }
    Expected_calls<-Expected_calls+Calls_to_make*(1-p_sub[Calls_to_make-1])
  }

    #(2) the expected profit from this strategy (weighted average of profitabilities forscenarios given this targeting plan, weighting each scenario by lift(n) and then adding together)
  
  
  Expected_profit <- 0
  if (Calls_to_make>0){
    for (i in 1:Calls_to_make){
      Expected_profit <-Expected_profit+lift[i]*(Success_profit-fail_cost*(i-1))
    }
    Expected_profit <-Expected_profit-fail_cost*Calls_to_make*(1-p_sub[Calls_to_make])
  } 

  Metrics <-c("Euribor","Max Calls","Expected Calls", "Profit")
  values<-c(Market_rate,Calls_to_make,Expected_calls,Expected_profit)
  results <-data.frame(Metrics,values)
#  print(results)
  
  return_frame <- data.frame(max_calls = Calls_to_make, p1 = prob[1], p2 = prob[2], p3 = prob[3], p4 = prob[4], p5 = prob[5])
  
  return(return_frame)
}

```


```{r}
# #Predict decisions (max calls to make) for test dataset using lasso
# 
# lasso_results <- data.frame(Max_calls_lasso = rep(0,nrow(df_test)), p1_lasso = rep(0,nrow(df_test)), p2_lasso = rep(0,nrow(df_test)), p3_lasso = rep(0,nrow(df_test)), p4_lasso = rep(0,nrow(df_test)), p5_lasso = rep(0,nrow(df_test)))
# 
# for (x in 1:nrow(df_test)) {
#   lasso_results[x,] <-Compute_Sample_Profitability_LASSO(x, cv_lasso)
#   }
# 
# df_test <- cbind(df_test,lasso_results)
# 
# hist(df_test$Max_calls_lasso)
# nrow(df_test[df_test$Max_calls_lasso<df_test$campaign])/nrow(df_test)

```

```{r}
# #Predict decisions (max calls to make) for test dataset using ridge
# 
# enet_results <- data.frame(Max_calls_enet = rep(0,nrow(df_test)), p1_enet = rep(0,nrow(df_test)), p2_enet = rep(0,nrow(df_test)), p3_enet = rep(0,nrow(df_test)), p4_enet = rep(0,nrow(df_test)), p5_enet = rep(0,nrow(df_test)))
# 
# for (x in 1:nrow(df_test)) {
#   enet_results[x,] <-Compute_Sample_Profitability_LASSO(x, cv_enet)
#   }
# 
# df_test <- cbind(df_test,enet_results)
# 
# hist(df_test$Max_calls_enet)
# nrow(df_test[df_test$Max_calls_enet<df_test$campaign])/nrow(df_test)

```

```{r}
# #Predict decisions (max calls to make) for test dataset using ridge
# 
# ridge_results <- data.frame(Max_calls_ridge = rep(0,nrow(df_test)), p1_ridge = rep(0,nrow(df_test)), p2_ridge = rep(0,nrow(df_test)), p3_ridge = rep(0,nrow(df_test)), p4_ridge = rep(0,nrow(df_test)), p5_ridge = rep(0,nrow(df_test)))
# 
# for (x in 1:nrow(df_test)) {
#   ridge_results[x,] <-Compute_Sample_Profitability_LASSO(x, cv_ridge)
#   }
# 
# df_test <- cbind(df_test,ridge_results)
# 
# hist(df_test$Max_calls_ridge)
# nrow(df_test[df_test$Max_calls_ridge<df_test$campaign])/nrow(df_test)

```

```{r}
# #make decision for logit (employment) model
# logit_results <- data.frame(Max_calls_logit = rep(0,nrow(df_test)), p1_logit = rep(0,nrow(df_test)), p2_logit = rep(0,nrow(df_test)), p3_logit = rep(0,nrow(df_test)), p4_logit = rep(0,nrow(df_test)), p5_logit = rep(0,nrow(df_test)))
# 
# suppressWarnings( for (x in 1:nrow(df_test)) {
#   logit_results[x,] <-Compute_Sample_Profitability(x)
#   }
# )
# 
# df_test <- cbind(df_test,logit_results)
# 
# hist(df_test$Max_calls_logit)
# nrow(df_test[df_test$Max_calls_logit<df_test$campaign])/nrow(df_test)

```

```{r}
# save(df_test,file='df_test.rda')

load(file='df_test.rda')
```

```{r}
#compute profit of calling all (as called)
baseline_profit <-0
for (x in 1:nrow(df_test)) {
  if(df_test$Class[x]=="FALSE") { baseline_profit<-baseline_profit-df_test$campaign[x]*fail_cost
                                } else { baseline_profit<-baseline_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
  
}
baseline_profit

#ridge profit
ridge_profit <-0
for (x in 1:nrow(df_test)) {
  if  (df_test$campaign[x]>df_test$Max_calls_ridge[x]){
       ridge_profit<-ridge_profit-df_test$Max_calls_ridge[x]*fail_cost 
      } else {
                if(df_test$Class[x]=="FALSE"){ 
                  ridge_profit<-ridge_profit-df_test$campaign[x]*fail_cost
                  } else { ridge_profit<-ridge_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
              }

}
ridge_profit

enet_profit <-0
for (x in 1:nrow(df_test)) {
  if  (df_test$campaign[x]>df_test$Max_calls_enet[x]){
      enet_profit<-enet_profit-df_test$Max_calls_enet[x]*fail_cost 
      } else {
                if(df_test$Class[x]=="FALSE"){ 
                  enet_profit<-enet_profit-df_test$campaign[x]*fail_cost
                  } else { enet_profit<-enet_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
              }

}
enet_profit

lasso_profit <-0
for (x in 1:nrow(df_test)) {
  if  (df_test$campaign[x]>df_test$Max_calls_lasso[x]){
      lasso_profit<-lasso_profit-df_test$Max_calls_lasso[x]*fail_cost 
      } else {
                if(df_test$Class[x]=="FALSE"){ 
                  lasso_profit<-lasso_profit-df_test$campaign[x]*fail_cost
                  } else { lasso_profit<-lasso_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
              }

}
lasso_profit

#compute "theoretical best profit" ->targeting only people who say yes
best_profit <-0
for (x in 1:nrow(df_test)) {
  if(df_test$Class[x]=="TRUE"){  
      best_profit<-best_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost
              }

}
NROW(df_test[df_test$Class=="TRUE"])
best_profit

#logit profit
logit_profit <-0
for (x in 1:nrow(df_test)) {
  if  (df_test$campaign[x]>df_test$Max_calls_logit[x]){
      logit_profit<-logit_profit-df_test$Max_calls_logit[x]*fail_cost 
      } else {
                if(df_test$Class[x]=="FALSE"){ 
                  logit_profit<-logit_profit-df_test$campaign[x]*fail_cost
                  } else { logit_profit<-logit_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
              }

}
logit_profit


#Gains
lasso_profit/baseline_profit-1

three_call_profit <-0
for (x in 1:nrow(df_test)) {
  if  (df_test$campaign[x]>3){
      three_call_profit<-three_call_profit-3*fail_cost 
      } else {
                if(df_test$Class[x]=="FALSE"){ 
                  three_call_profit<-three_call_profit-df_test$campaign[x]*fail_cost
                  } else { three_call_profit<-three_call_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
              }

}

two_call_profit <-0
for (x in 1:nrow(df_test)) {
  if  (df_test$campaign[x]>2){
      two_call_profit<-two_call_profit-2*fail_cost 
      } else {
                if(df_test$Class[x]=="FALSE"){ 
                  two_call_profit<-two_call_profit-df_test$campaign[x]*fail_cost
                  } else { two_call_profit<-two_call_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
              }

}

barplot(c(baseline_profit,two_call_profit,three_call_profit,logit_profit,lasso_profit, enet_profit,ridge_profit, best_profit), names = c("baseline","two-call","three-call","logit","lasso","enet","ridge","max profit"),ylim=c(0,22000))
#text(x=1:5,y=c(baseline_profit,two_call_profit,three_call_profit,logit_profit,lasso_profit)+300,labels = c(baseline_profit,two_call_profit,three_call_profit,logit_profit,lasso_profit))

```

```{r}
model_curve_lasso <- data.frame(n = seq(from = .01, to= 1, by = .01), lasso_profit = 0)

for (n in 1:nrow(df_test)){
  df_test_profit <- df_test[n, current_prob := get(paste0("p",df_test$campaign[n],"_lasso"))]
}
df_test_profit[,rank := frank(current_prob)]
df_test_profit <- df_test_profit[order(-rank)]

for (p in seq(from = .01, to= 1, by = .01)){
  num<-round(nrow(df_test_profit)*p)
  model_curve_lasso[p*100,2] <- df_test_profit[1:num, sum(Class)]*Success_profit - (num-df_test_profit[1:num, sum(Class)])*fail_cost
}

for (p in c(.06,.07)){
  num<-round(nrow(df_test_profit)*p)
  model_curve_lasso[p*100,2] <- df_test_profit[1:num, sum(Class)]*Success_profit - (num-df_test_profit[1:num, sum(Class)])*fail_cost
}
```

```{r}
model_curve_logit <- data.frame(n = seq(from = .01, to= 1, by = .01), logit_profit = 0)

for (n in 1:nrow(df_test)){
  df_test_profit <- df_test[n, current_prob := get(paste0("p",df_test$campaign[n],"_logit"))]
}
df_test_profit[,rank := frank(current_prob)]
df_test_profit <- df_test_profit[order(-rank)]

for (p in seq(from = .01, to= 1, by = .01)){
  num<-round(nrow(df_test_profit)*p)
  model_curve_logit[p*100,2] <- df_test_profit[1:num, sum(Class)]*Success_profit - (num-df_test_profit[1:num, sum(Class)])*fail_cost
}

for (p in c(.06,.07)){
  num<-round(nrow(df_test_profit)*p)
  model_curve_logit[p*100,2] <- df_test_profit[1:num, sum(Class)]*Success_profit - (num-df_test_profit[1:num, sum(Class)])*fail_cost
}

```

```{r}
model_curve_random <- data.frame(n = seq(from = .01, to= 1, by = .01), random_profit = 0)

random_order <- sample(1:nrow(df_test),size=nrow(df_test),replace=FALSE)
df_test_profit <- df_test[order(random_order)]

for (p in seq(from = .01, to= 1, by = .01)){
  num<-round(nrow(df_test_profit)*p)
  model_curve_random[p*100,2] <- df_test_profit[1:num, sum(Class)]*Success_profit - (num-df_test_profit[1:num, sum(Class)])*fail_cost
}

for (p in c(.06,.07)){
  num<-round(nrow(df_test_profit)*p)
  model_curve_random[p*100,2] <- df_test_profit[1:num, sum(Class)]*Success_profit - (num-df_test_profit[1:num, sum(Class)])*fail_cost
}

```

```{r}
model_curve <- cbind(model_curve_logit,lasso_profit = model_curve_lasso$lasso_profit, random_profit = model_curve_random$random_profit)

ggplot(data=model_curve, main="Profit Curve by Percent Targeted", xlab = "Percent Targeted", ylab = "Profit") + geom_line(aes(x=n,y=lasso_profit,col='LASSO')) + geom_line(aes(x=n,y=logit_profit, col = 'Logit')) + geom_line(aes(x=n,y=random_profit, col = 'Random'))
```

```{r}
### KNN - euclidean approach. when using full_df, there are no predicted conversions
TrnX <- df_train[,1:30]
OrigTrnG <- df_train$Class

TstX <- df_test[,1:30]

# nnresult <- data.frame("Neighbors" = NULL, "Total_Calls" = NULL, "Good_Calls" = NULL, "Total_Profit" = NULL)
# for (i in 1:20){
#   nn <- knn(TrnX, TstX, OrigTrnG, k=i, l = 0, prob=FALSE, use.all = FALSE)
#   nn <- cbind(nn,df_test[,56])
# 
#   nn$call <- 0
#   nn$call[nn$nn==TRUE] <- 1
# 
#   nn$match <- nn$nn == nn$Class & nn$Class== TRUE
#   nn$profit <- 0
#   nn$profit[nn$match==TRUE] <- Success_profit
# 
#   nn$failcall <- nn$nn == TRUE & nn$Class == FALSE
#   nn$failcost <-0
#   nn$failcost[nn$failcall==TRUE] <- fail_cost
# 
#   thisresult <- data.frame("Neighbors" = i ,
#                            "Total_Calls" = sum(nn$call),
#                            "Good_Calls" = length(nn$match[nn$match==TRUE]),
#                            "Total_Profit" = sum(nn$profit) - sum(nn$failcost)
#                            )
# 
# 
#   nnresult <- rbind(nnresult, thisresult)
# }
# save(nnresult, file="nnresult.rda")
load(file="nnresult.rda")
write.csv(nnresult, "knn_result.csv")
nnresult


### KNN with Mahalanobis distances: computationally taxing; cannot compute enough to compare against model
## first Mahalanobis approach: knnGarden package
#install.packages("knnGarden")
#knnMCN(TrnX=TrnX[1:1000,],OrigTrnG=OrigTrnG[1:1000],TstX=TstX[1:200,],ShowObs=FALSE,K=1)

## second Mahalanobis approach: pvclass package. computationally taxing; subsetted to 1000 rows in dev 
#knnout <- cvpvs.knn(TrnX[1:1000], OrigTrnG[1:1000], k = 1, distance = 'mahalanobis', cova = 'standard')
```



## Warren's Todo

* update trees to predict probabilities
* update prediction algorithm to evaluate profit with matrix vs. individual


## Regression Tree
```{r}
set.seed(99)
fit1 = rpart(Class~., data=model_df, control=rpart.control(minsplit=5, cp=0.0001, xval=10))

nbig = length(unique(fit1$where))
cat('Size of big tree: ',nbig,'\n')

cat('RMSE=',sqrt(mean((df_test$Class-predict(fit1,df_test))^2)),'\n')

(cptable = printcp(fit1))
(bestcp = cptable[ which.min(cptable[,"xerror"]), "CP" ])   
fit1B = prune(fit1,cp=bestcp)
nbigB = length(unique(fit1B$where))
cat('Size of pruned tree: ',nbigB,'\n')

cat('RMSE=',sqrt(mean((df_test$Class-predict(fit1B,df_test))^2)),'\n')
```

```{r}
#Generate estimates of cost per call, benefit (revenue/profit) of time deposit product for bank

        #Cost- Relevant inputs: hourly wage, average call information (separate averages for failures and successes          b/c they have drastically different lengths)

Compute_Sample_Profitability_Tree<-function(obs){
          sample_person <-df_test[obs]
          
#Loops through prediction turning on campaigns to calculate probabilities of success on calls 1:5
prob <-rep(NA,5)
    sample_person$campaign2<-0
    sample_person$campaign3<-0
    sample_person$campaign4<-0
    sample_person$campaign5<-0
    tree_test<-sample_person[,c(56,1:30,47:49, 58:61)]
prob[1] <- predict(fit1,newx=tree_test)[obs]
    sample_person$campaign2<-1
prob[2] <- predict(fit1,newx=tree_test)[obs]
    sample_person$campaign2<-0
    sample_person$campaign3<-1
prob[3] <- predict(fit1,newx=tree_test)[obs]
    sample_person$campaign3<-0
    sample_person$campaign4<-1
prob[4] <- predict(fit1,newx=tree_test)[obs]
    sample_person$campaign4<-0
    sample_person$campaign5<-1
prob[5] <- predict(fit1,newx=tree_test)[obs]


    #For Calls 1 through N, compute likelihood of success by the nth call: p_sub(n)
        
p_sub<-rep(NA,5)
  p_sub[1]<-prob[1]
  for (i in 2:5) {
    p_sub[i] <-p_sub[i-1]+prob[i]*(1-p_sub[i-1])
  }

  
  #For calls 1 through N, compute lift of call n: lift(n)= p_sub(n) - p_sub(n-1) (this represents unconditional probability of success on call n)
lift<-rep(NA,5)
  lift[1]<-p_sub[1]
  for (i in 2:5) {
    lift[i] <-p_sub[i]-p_sub[i-1]
  }
  
#Compute number of calls to target for a given customer (N.B.: As long as probability of success is declining monotonically, as soon as the nth call is not profitable, the (n+1)th call will also not be profitable.) 
  #Test: Identify whether the nth call (if made) would be profitable. THis is simple:
   #Profit(n|All calls prior="no")=[Profit of Success]*p_sub(n) -[Cost of Failure]*(1-p_sub(n)) 
  Profit <- rep(NA,5)
  for (i in 1:5){
    Profit[i] <- Success_profit*prob[i]-fail_cost*(1-prob[i])
  }
  #Decision: for the first unprofitable call "A," choose  A-1 as the target number of calls.
  Calls_to_make<-0
  Calls_to_make <-NROW(Profit[Profit>0])
  #based out this decision (target customer with A-1 calls), also compute 
    #(1) the expected number of calls with that rule(this is not simply A-1 b/c customer may sign up earlier), and
Expected_calls <- 0
if(Calls_to_make<=1) {
  Expected_calls<-Calls_to_make
}  else {
    for (i in 1:(Calls_to_make-1)){
      Expected_calls<-Expected_calls+i*lift[i]
    }
    Expected_calls<-Expected_calls+Calls_to_make*(1-p_sub[Calls_to_make-1])
  }

    #(2) the expected profit from this strategy (weighted average of profitabilities forscenarios given this targeting plan, weighting each scenario by lift(n) and then adding together)
  
  
  Expected_profit <- 0
  if (Calls_to_make>0){
    for (i in 1:Calls_to_make){
      Expected_profit <-Expected_profit+lift[i]*(Success_profit-fail_cost*(i-1))
    }
    Expected_profit <-Expected_profit-fail_cost*Calls_to_make*(1-p_sub[Calls_to_make])
  } 

  Metrics <-c("Euribor","Max Calls","Expected Calls", "Profit")
  values<-c(Market_rate,Calls_to_make,Expected_calls,Expected_profit)
  results <-data.frame(Metrics,values)
#  print(results)
  
  return(Calls_to_make)

}



```

```{r}
df_test$Max_calls_tree<-0

for (x in 1:nrow(df_test)) {
    df_test$Max_calls_tree[x] <-Compute_Sample_Profitability_Tree(x)
  }

hist(df_test$Max_calls_tree)
nrow(df_test[df_test$Max_calls_tree<df_test$campaign])/nrow(df_test)

```

```{r}

#tree profit
tree_profit <-0
for (x in 1:nrow(df_test)) {
  if  (df_test$campaign[x]>df_test$Max_calls_tree[x]){
      -df_test$Max_calls_tree[x]*fail_cost 
      } else {
                if(df_test$Class[x]=="FALSE"){ 
                  tree_profit<-tree_profit-df_test$campaign[x]*fail_cost
                  } else { tree_profit<-tree_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
              }

}
tree_profit

```




## Random Forest
```{r tree all vars, echo=FALSE}
set.seed(99)
fit2 <- randomForest(Class~., data=model_df, type="regression")
cat('RMSE is ',sqrt(mean((df_test$Class - (predict(fit2, df_test)))^2)),'\n')

```


```{r}
#Generate estimates of cost per call, benefit (revenue/profit) of time deposit product for bank

        #Cost- Relevant inputs: hourly wage, average call information (separate averages for failures and successes          b/c they have drastically different lengths)

Compute_Sample_Profitability_RF<-function(obs){
          sample_person <-df_test[obs]
          
#Loops through prediction turning on campaigns to calculate probabilities of success on calls 1:5
prob <-rep(NA,5)
    sample_person$campaign2<-0
    sample_person$campaign3<-0
    sample_person$campaign4<-0
    sample_person$campaign5<-0
    rf_test<-sample_person[,c(56,1:30,47:49, 58:61)]
prob[1] <- predict(fit2,newx=rf_test)[obs]
    sample_person$campaign2<-1
prob[2] <- predict(fit2,newx=rf_test)[obs]
    sample_person$campaign2<-0
    sample_person$campaign3<-1
prob[3] <- predict(fit2,newx=rf_test)[obs]
    sample_person$campaign3<-0
    sample_person$campaign4<-1
prob[4] <- predict(fit2,newx=rf_test)[obs]
    sample_person$campaign4<-0
    sample_person$campaign5<-1
prob[5] <- predict(fit2,newx=rf_test)[obs]


    #For Calls 1 through N, compute likelihood of success by the nth call: p_sub(n)
        
p_sub<-rep(NA,5)
  p_sub[1]<-prob[1]
  for (i in 2:5) {
    p_sub[i] <-p_sub[i-1]+prob[i]*(1-p_sub[i-1])
  }

  
  #For calls 1 through N, compute lift of call n: lift(n)= p_sub(n) - p_sub(n-1) (this represents unconditional probability of success on call n)
lift<-rep(NA,5)
  lift[1]<-p_sub[1]
  for (i in 2:5) {
    lift[i] <-p_sub[i]-p_sub[i-1]
  }
  
#Compute number of calls to target for a given customer (N.B.: As long as probability of success is declining monotonically, as soon as the nth call is not profitable, the (n+1)th call will also not be profitable.) 
  #Test: Identify whether the nth call (if made) would be profitable. THis is simple:
   #Profit(n|All calls prior="no")=[Profit of Success]*p_sub(n) -[Cost of Failure]*(1-p_sub(n)) 
  Profit <- rep(NA,5)
  for (i in 1:5){
    Profit[i] <- Success_profit*prob[i]-fail_cost*(1-prob[i])
  }
  #Decision: for the first unprofitable call "A," choose  A-1 as the target number of calls.
  Calls_to_make<-0
  Calls_to_make <-NROW(Profit[Profit>0])
  #based out this decision (target customer with A-1 calls), also compute 
    #(1) the expected number of calls with that rule(this is not simply A-1 b/c customer may sign up earlier), and
Expected_calls <- 0
if(Calls_to_make<=1) {
  Expected_calls<-Calls_to_make
}  else {
    for (i in 1:(Calls_to_make-1)){
      Expected_calls<-Expected_calls+i*lift[i]
    }
    Expected_calls<-Expected_calls+Calls_to_make*(1-p_sub[Calls_to_make-1])
  }



    #(2) the expected profit from this strategy (weighted average of profitabilities forscenarios given this targeting plan, weighting each scenario by lift(n) and then adding together)
  
  
  Expected_profit <- 0
  if (Calls_to_make>0){
    for (i in 1:Calls_to_make){
      Expected_profit <-Expected_profit+lift[i]*(Success_profit-fail_cost*(i-1))
    }
    Expected_profit <-Expected_profit-fail_cost*Calls_to_make*(1-p_sub[Calls_to_make])
  } 

  Metrics <-c("Euribor","Max Calls","Expected Calls", "Profit")
  values<-c(Market_rate,Calls_to_make,Expected_calls,Expected_profit)
  results <-data.frame(Metrics,values)
#  print(results)
  
  return(Calls_to_make)

}



```

```{r}
df_test$Max_calls_rf<-0

for (x in 1:nrow(df_test)) {
    df_test$Max_calls_rf[x] <-Compute_Sample_Profitability_RF(x)
  }

hist(df_test$Max_calls_rf)
nrow(df_test[df_test$Max_calls_rf<df_test$campaign])/nrow(df_test)

```

```{r}

#tree profit
rf_profit <-0
for (x in 1:nrow(df_test)) {
  if  (df_test$campaign[x]>df_test$Max_calls_rf[x]){
      -df_test$Max_calls_rf[x]*fail_cost 
      } else {
                if(df_test$Class[x]=="FALSE"){ 
                  rf_profit<-rf_profit-df_test$campaign[x]*fail_cost
                  } else { rf_profit<-rf_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
              }

}
rf_profit

```


## Boosting
```{r boosting}
set.seed(99)
# Inputs, Regression Setting
fboost <- gbm(Class~.,           # regression model
           data=model_df,              # data set
           distribution="bernoulli", # logistic regression for 0-1 outcomes
           n.trees=500,             # Total number of trees/iterations
           interaction.depth = 1,   #1 means additive, 2 means 2-way interaction, etc
           shrinkage=0.1           # Shrinkage parameter, weak predictor
           )

# Returned Values, Returned predictor
# Making prediction
cat('RMSE is',sqrt(mean((df_test$Class-log_prob(predict(fboost,newdata=df_test,n.trees=500)))^2)),'\n')
```


```{r}


df_test$Max_calls_gbm<-0


#Generate estimates of cost per call, benefit (revenue/profit) of time deposit product for bank

        #Cost- Relevant inputs: hourly wage, average call information (separate averages for failures and successes          b/c they have drastically different lengths)

gbm_test <-df_test[,c(56,1:30,47:49, 58:61)]
          
#Loops through prediction turning on campaigns to calculate probabilities of success on calls 1:5
prob <-rep(NA,5)
    gbm_test$campaign2<-0
    gbm_test$campaign3<-0
    gbm_test$campaign4<-0
    gbm_test$campaign5<-0

prob[1] <- log_prob(predict(fboost,newx=gbm_test, n.trees=500))
    gbm_test$campaign2<-1
prob[2] <- log_prob(predict(fboost,newx=gbm_test, n.trees=500))
    gbm_test$campaign2<-0
    gbm_test$campaign3<-1
prob[3] <- log_prob(predict(fboost,newx=gbm_test, n.trees=500))
    gbm_test$campaign3<-0
    gbm_test$campaign4<-1
prob[4] <- log_prob(predict(fboost,newx=gbm_test, n.trees=500))
    gbm_test$campaign4<-0
    gbm_test$campaign5<-1
prob[5] <- log_prob(predict(fboost,newx=gbm_test, n.trees=500))


    #For Calls 1 through N, compute likelihood of success by the nth call: p_sub(n)
        
p_sub<-rep(NA,5)
  p_sub[1]<-prob[1]
  for (i in 2:5) {
    p_sub[i] <-p_sub[i-1]+prob[i]*(1-p_sub[i-1])
  }

  
  #For calls 1 through N, compute lift of call n: lift(n)= p_sub(n) - p_sub(n-1) (this represents unconditional probability of success on call n)
lift<-rep(NA,5)
  lift[1]<-p_sub[1]
  for (i in 2:5) {
    lift[i] <-p_sub[i]-p_sub[i-1]
  }
  
#Compute number of calls to target for a given customer (N.B.: As long as probability of success is declining monotonically, as soon as the nth call is not profitable, the (n+1)th call will also not be profitable.) 
  #Test: Identify whether the nth call (if made) would be profitable. THis is simple:
   #Profit(n|All calls prior="no")=[Profit of Success]*p_sub(n) -[Cost of Failure]*(1-p_sub(n)) 
  Profit <- rep(NA,5)
  for (i in 1:5){
    Profit[i] <- Success_profit*prob[i]-fail_cost*(1-prob[i])
  }
  #Decision: for the first unprofitable call "A," choose  A-1 as the target number of calls.
  Calls_to_make<-0
  Calls_to_make <-NROW(Profit[Profit>0])
  #based out this decision (target customer with A-1 calls), also compute 
    #(1) the expected number of calls with that rule(this is not simply A-1 b/c customer may sign up earlier), and
Expected_calls <- 0
if(Calls_to_make<=1) {
  Expected_calls<-Calls_to_make
}  else {
    for (i in 1:(Calls_to_make-1)){
      Expected_calls<-Expected_calls+i*lift[i]
    }
    Expected_calls<-Expected_calls+Calls_to_make*(1-p_sub[Calls_to_make-1])
  }

    #(2) the expected profit from this strategy (weighted average of profitabilities forscenarios given this targeting plan, weighting each scenario by lift(n) and then adding together)
  
  
  Expected_profit <- 0
  if (Calls_to_make>0){
    for (i in 1:Calls_to_make){
      Expected_profit <-Expected_profit+lift[i]*(Success_profit-fail_cost*(i-1))
    }
    Expected_profit <-Expected_profit-fail_cost*Calls_to_make*(1-p_sub[Calls_to_make])
  } 

  Metrics <-c("Euribor","Max Calls","Expected Calls", "Profit")
  values<-c(Market_rate,Calls_to_make,Expected_calls,Expected_profit)
  results <-data.frame(Metrics,values)
#  print(results)
  

df_test$Max_calls_gbm[x]<-Calls_to_make

```

```{r}


hist(df_test$Max_calls_gbm)
nrow(df_test[df_test$Max_calls_gbm<df_test$campaign])/nrow(df_test)

```

```{r}

#tree profit
rf_profit <-0
for (x in 1:nrow(df_test)) {
  if  (df_test$campaign[x]>df_test$Max_calls_rf[x]){
      -df_test$Max_calls_rf[x]*fail_cost 
      } else {
                if(df_test$Class[x]=="FALSE"){ 
                  rf_profit<-rf_profit-df_test$campaign[x]*fail_cost
                  } else { rf_profit<-rf_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
              }

}
rf_profit

```




#--Simple Regression Stuff--
```{r}
# reg <- glm(outcome~.-duration, family="binomial", data=df_train)
# summary(reg)
```

# Basic prediction exercise 
High accuracy but mostly driven by high count of true falses
```{r}
# pred_test <- ifelse(predict(reg, df_test, type="response")>0.5,TRUE,FALSE)
# confusionMatrix(pred_test,df_test$Class)
```


# Simple target top 100
```{r}
# pred_test1 <- predict(reg, df_test, type="response")
# test1_index <- sort(pred_test1, index.return=TRUE, decreasing=TRUE)$ix[1:100]
# pred_test1tf <- ifelse(pred_test1[test1_index]>0.5,TRUE,FALSE)
# confusionMatrix(pred_test1tf,df_test$Class[test1_index])
```

# Can we pick those with greater than 50% odds of responding?
```{r}
# pred_test2 <- predict(reg, df_test, type="response")
# num_true_pred2 <- sum(sort(pred_test2, index.return=TRUE, decreasing=TRUE)$x>0.5)
# test2_index <- sort(pred_test2, index.return=TRUE, decreasing=TRUE)$ix[1:num_true_pred2]
# pred_test2tf <- ifelse(pred_test2[test2_index]>0.5,TRUE,FALSE)
# confusionMatrix(pred_test2tf,df_test$Class[test2_index])
```





