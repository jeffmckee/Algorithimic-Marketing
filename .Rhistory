Expected_profit <-Expected_profit+lift[i]*(Success_profit-fail_cost*(i-1))
}
Expected_profit <-Expected_profit-fail_cost*Calls_to_make*(1-p_sub[Calls_to_make])
}
Metrics <-c("Euribor","Max Calls","Expected Calls", "Profit")
values<-c(Market_rate,Calls_to_make,Expected_calls,Expected_profit)
results <-data.frame(Metrics,values)
#  print(results)
data.frame('Calls' = Calls_to_make, unlist(prob))
data.frame('Calls' = Calls_to_make, P1 = prob[1], P2 = prob[2], P3 = prob[3], P4 = prob[4], P5 = prob[5])
knitr::opts_chunk$set(echo = TRUE)
library(caret)
library(data.table)
library(glmnet)
library(rpart)
library(rpart.plot)
library(randomForest)
library(xgboost)
library(gbm)
library(class)
library(pvclass)
library(knnGarden)
log_prob <- function(pred){
1/(1+exp(-pred))
}
df <- read.csv("bank_additional_full.csv")
levels(df$job)[2] <- "bluecollar"
levels(df$job)[7] <- "selfemployed"
df <- as.data.table(model.matrix(~.-1,df))
# colnames(df)[colnames(df)=="ytrue"] <- "outcome"
df$Class <- ifelse(df$ytrue==1,TRUE,FALSE)
#
# summary(df)
# str(df)
# table(df$campaign)
#
# barplot(table(df$Class,df$campaign)[2,1:15]/(table(df$Class,df$campaign)[1,1:15]+table(df$Class,df$campaign)[2,1:15]))
summary(df$Class)
NROW(df$Class[df$Class=='TRUE'])/NROW(df$Class)
df[,ID := .I]
#split into test and train
set.seed(99)
training_size <- floor(0.80 * nrow(df))
train_ind <- sample(seq_len(nrow(df)), size = training_size)
df_train <- df[train_ind, ]
df_test <- df[-train_ind, ]
df_test[df_test$campaign>5,'Class']<-FALSE
df_test$campaign[df_test$campaign>5]<-5
df_test[,campaign2 := ifelse(campaign == 2, 1,0)]
df_test[,campaign3 := ifelse(campaign == 3, 1,0)]
df_test[,campaign4 := ifelse(campaign == 4, 1,0)]
df_test[,campaign5 := ifelse(campaign == 5, 1,0)]
# Work on training data
full_df <- df_train[rep(1:.N,campaign)][,campaign_no:=1:.N,by=ID]
full_df[campaign != campaign_no,'Class'] <- FALSE
full_df[,campaign2 := ifelse(campaign_no == 2, 1,0)]
full_df[,campaign3 := ifelse(campaign_no == 3, 1,0)]
full_df[,campaign4 := ifelse(campaign_no == 4, 1,0)]
full_df[,campaign5 := ifelse(campaign_no == 5, 1,0)]
model_df<-full_df[campaign_no<=5,c(56,1:30,47:49, 59:62)]
x_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5-1,data=model_df)
# foldid=sample(1:10,size=length(model_df$Class),replace=TRUE)
# cv_ridge <- cv.glmnet(x=x_matrix, y=model_df$Class, foldid=foldid, lambda = exp(seq(from = -10, to = 0, by = .1)), family="binomial",alpha=0)
# cv_enet <- cv.glmnet(x=x_matrix, y=model_df$Class, foldid=foldid, lambda = exp(seq(from = -10, to = 0, by = .1)), family="binomial",alpha=.5)
# cv_lasso <- cv.glmnet(x=x_matrix, y=model_df$Class, foldid=foldid, lambda = exp(seq(from = -10, to = 0, by = .1)), family="binomial",alpha=1)
#
# save(cv_ridge, file="cv_ridge.rda")
# save(cv_lasso, file="cv_lasso.rda")
# save(cv_enet, file="cv_enet.rda")
load(file="cv_ridge.rda")
load(file="cv_lasso.rda")
load(file="cv_enet.rda")
plot(log(cv_lasso$lambda),cv_lasso$cvm,pch=19,col="red",xlab="log(Lambda)",ylab=cv_lasso$name)
points(log(cv_enet$lambda),cv_enet$cvm,pch=19,col="grey")
points(log(cv_ridge$lambda),cv_ridge$cvm,pch=19,col="blue")
legend("topleft",legend=c("alpha= 1","alpha= .5","alpha 0"),pch=19,col=c("red","grey","blue"))
# test_reg   <-glm(Class~(age+jobadmin.+jobbluecollar+jobentrepreneur+jobhousemaid+jobmanagement+jobretired+jobselfemployed+jobservices+jobstudent+jobtechnician+jobunemployed+jobunknown) *( campaign2+campaign3)+campaign4+campaign5+maritalsingle+maritalunknown+educationbasic.6y+educationbasic.9y+educationhigh.school+educationilliterate+educationprofessional.course+educationuniversity.degree+educationunknown+defaultunknown+defaultyes+housingunknown+housingyes+loanunknown+loanyes,family='binomial',data=model_df)
#ASSUMPTIONS:
wage <-12 #Estimate of hourly wage
fail_time <-mean(df$duration[df$Class=="FALSE"]) / 3600
success_time <-mean(df$duration[df$Class=="TRUE"]) / 3600
Inter_call_time <-1/60
fail_cost<-wage*(fail_time+Inter_call_time)
success_cost <-wage*(success_time+Inter_call_time)
#Output: [cost of failure], [cost of success/signup]
#Profit from successful customer: According to a paper, CD rates in the Netherlands average ~60% of Euribor rates (https://onlinelibrary.wiley.com/doi/full/10.1111/irfi.12143)
Market_rate <-.025
CD_rate <-Market_rate*.6
Balance<-10000 #(simply assumed)
Term <- .25 #(.25 years, assumed based on rate)
Revenue <- Balance*Term*(Market_rate-CD_rate)  #(roughly a function of not having to borrow this money at market rates, flat curve assumed)
Success_profit <-Revenue - success_cost
#Generate estimates of cost per call, benefit (revenue/profit) of time deposit product for bank
#Cost- Relevant inputs: hourly wage, average call information (separate averages for failures and successes          b/c they have drastically different lengths)
Compute_Sample_Profitability<-function(obs){
sample_person <-df_test[obs]
#from regression coefficients + person's info: Simple prediction of success likelihood on the nth call "prob(n)" (conditional on failures for all previous calls)
#Loops through prediction turning on campaigns to calculate probabilities of success on calls 1:5
prob <-rep(NA,5)
sample_person$campaign2<-0
sample_person$campaign3<-0
sample_person$campaign4<-0
sample_person$campaign5<-0
prob[1] <-log_prob(predict(test_reg,sample_person))
sample_person$campaign2<-1
prob[2] <-log_prob(predict(test_reg,sample_person))
sample_person$campaign2<-0
sample_person$campaign3<-1
prob[3] <-log_prob(predict(test_reg,sample_person))
sample_person$campaign3<-0
sample_person$campaign4<-1
prob[4] <-log_prob(predict(test_reg,sample_person))
sample_person$campaign4<-0
sample_person$campaign5<-1
prob[5] <-log_prob(predict(test_reg,sample_person))
sample_person$campaign5<-0
#For Calls 1 through N, compute likelihood of success by the nth call: p_sub(n)
p_sub<-rep(NA,5)
p_sub[1]<-prob[1]
for (i in 2:5) {
p_sub[i] <-p_sub[i-1]+prob[i]*(1-p_sub[i-1])
}
#For calls 1 through N, compute lift of call n: lift(n)= p_sub(n) - p_sub(n-1) (this represents unconditional probability of success on call n)
lift<-rep(NA,5)
lift[1]<-p_sub[1]
for (i in 2:5) {
lift[i] <-p_sub[i]-p_sub[i-1]
}
#Compute number of calls to target for a given customer (N.B.: As long as probability of success is declining monotonically, as soon as the nth call is not profitable, the (n+1)th call will also not be profitable.)
#Test: Identify whether the nth call (if made) would be profitable. THis is simple:
#Profit(n|All calls prior="no")=[Profit of Success]*p_sub(n) -[Cost of Failure]*(1-p_sub(n))
Profit <- rep(NA,5)
for (i in 1:5){
Profit[i] <- Success_profit*prob[i]-fail_cost*(1-prob[i])
}
#Decision: for the first unprofitable call "A," choose  A-1 as the target number of calls.
Calls_to_make<-0
Calls_to_make <-NROW(Profit[Profit>0])
#based out this decision (target customer with A-1 calls), also compute
#(1) the expected number of calls with that rule(this is not simply A-1 b/c customer may sign up earlier), and
Expected_calls <- 0
if(Calls_to_make<=1) {
Expected_calls<-Calls_to_make
}  else {
for (i in 1:(Calls_to_make-1)){
Expected_calls<-Expected_calls+i*lift[i]
}
Expected_calls<-Expected_calls+Calls_to_make*(1-p_sub[Calls_to_make-1])
}
#(2) the expected profit from this strategy (weighted average of profitabilities forscenarios given this targeting plan, weighting each scenario by lift(n) and then adding together)
Expected_profit <- 0
if (Calls_to_make>0){
for (i in 1:Calls_to_make){
Expected_profit <-Expected_profit+lift[i]*(Success_profit-fail_cost*(i-1))
}
Expected_profit <-Expected_profit-fail_cost*Calls_to_make*(1-p_sub[Calls_to_make])
}
Metrics <-c("Euribor","Max Calls","Expected Calls", "Profit")
values<-c(Market_rate,Calls_to_make,Expected_calls,Expected_profit)
results <-data.frame(Metrics,values)
#  print(results)
return(Calls_to_make)
}
#Generate estimates of cost per call, benefit (revenue/profit) of time deposit product for bank
#Cost- Relevant inputs: hourly wage, average call information (separate averages for failures and successes          b/c they have drastically different lengths)
Compute_Sample_Profitability_LASSO<-function(obs,model){
sample_person <-df_test[obs]
#Loops through prediction turning on campaigns to calculate probabilities of success on calls 1:5
prob <-rep(NA,5)
sample_person$campaign2<-0
sample_person$campaign3<-0
sample_person$campaign4<-0
sample_person$campaign5<-0
lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5-1,data=lasso_test)
prob[1] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
sample_person$campaign2<-1
lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5-1,data=lasso_test)
prob[2] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
sample_person$campaign2<-0
sample_person$campaign3<-1
lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5-1,data=lasso_test)
prob[3] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
sample_person$campaign3<-0
sample_person$campaign4<-1
lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5-1,data=lasso_test)
prob[4] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
sample_person$campaign4<-0
sample_person$campaign5<-1
lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5-1,data=lasso_test)
prob[5] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
#For Calls 1 through N, compute likelihood of success by the nth call: p_sub(n)
p_sub<-rep(NA,5)
p_sub[1]<-prob[1]
for (i in 2:5) {
p_sub[i] <-p_sub[i-1]+prob[i]*(1-p_sub[i-1])
}
#For calls 1 through N, compute lift of call n: lift(n)= p_sub(n) - p_sub(n-1) (this represents unconditional probability of success on call n)
lift<-rep(NA,5)
lift[1]<-p_sub[1]
for (i in 2:5) {
lift[i] <-p_sub[i]-p_sub[i-1]
}
#Compute number of calls to target for a given customer (N.B.: As long as probability of success is declining monotonically, as soon as the nth call is not profitable, the (n+1)th call will also not be profitable.)
#Test: Identify whether the nth call (if made) would be profitable. THis is simple:
#Profit(n|All calls prior="no")=[Profit of Success]*p_sub(n) -[Cost of Failure]*(1-p_sub(n))
Profit <- rep(NA,5)
for (i in 1:5){
Profit[i] <- Success_profit*prob[i]-fail_cost*(1-prob[i])
}
#Decision: for the first unprofitable call "A," choose  A-1 as the target number of calls.
Calls_to_make<-0
Calls_to_make <-NROW(Profit[Profit>0])
#based out this decision (target customer with A-1 calls), also compute
#(1) the expected number of calls with that rule(this is not simply A-1 b/c customer may sign up earlier), and
Expected_calls <- 0
if(Calls_to_make<=1) {
Expected_calls<-Calls_to_make
}  else {
for (i in 1:(Calls_to_make-1)){
Expected_calls<-Expected_calls+i*lift[i]
}
Expected_calls<-Expected_calls+Calls_to_make*(1-p_sub[Calls_to_make-1])
}
#(2) the expected profit from this strategy (weighted average of profitabilities forscenarios given this targeting plan, weighting each scenario by lift(n) and then adding together)
Expected_profit <- 0
if (Calls_to_make>0){
for (i in 1:Calls_to_make){
Expected_profit <-Expected_profit+lift[i]*(Success_profit-fail_cost*(i-1))
}
Expected_profit <-Expected_profit-fail_cost*Calls_to_make*(1-p_sub[Calls_to_make])
}
Metrics <-c("Euribor","Max Calls","Expected Calls", "Profit")
values<-c(Market_rate,Calls_to_make,Expected_calls,Expected_profit)
results <-data.frame(Metrics,values)
#  print(results)
return_frame <- data.frame('Calls' = Calls_to_make, P1 = prob[1], P2 = prob[2], P3 = prob[3], P4 = prob[4], P5 = prob[5])
return(return_frame)
}
Compute_Sample_Profitability_LASSO(1, cv_ridge)
?rep
nrow(df_test)
ridge_results <- data.frame(max_calls = rep(0,nrow(df_test)), p1 = rep(0,nrow(df_test)), p2 = rep(0,nrow(df_test)), p3 = rep(0,nrow(df_test)), p4 = rep(0,nrow(df_test)), p5 = rep(0,nrow(df_test)))
for (x in 1:nrow(df_test)) {
ridge_results[x,] <-Compute_Sample_Profitability_LASSO(x, cv_ridge)
}
ridge_results
cbind(df_test,ridge_results)
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)
library(caret)
library(data.table)
library(glmnet)
library(rpart)
library(rpart.plot)
library(randomForest)
library(xgboost)
library(gbm)
library(class)
library(pvclass)
library(knnGarden)
log_prob <- function(pred){
1/(1+exp(-pred))
}
df <- read.csv("bank_additional_full.csv")
levels(df$job)[2] <- "bluecollar"
levels(df$job)[7] <- "selfemployed"
df <- as.data.table(model.matrix(~.-1,df))
# colnames(df)[colnames(df)=="ytrue"] <- "outcome"
df$Class <- ifelse(df$ytrue==1,TRUE,FALSE)
#
# summary(df)
# str(df)
# table(df$campaign)
#
# barplot(table(df$Class,df$campaign)[2,1:15]/(table(df$Class,df$campaign)[1,1:15]+table(df$Class,df$campaign)[2,1:15]))
summary(df$Class)
NROW(df$Class[df$Class=='TRUE'])/NROW(df$Class)
df[,ID := .I]
#split into test and train
set.seed(99)
training_size <- floor(0.80 * nrow(df))
train_ind <- sample(seq_len(nrow(df)), size = training_size)
df_train <- df[train_ind, ]
df_test <- df[-train_ind, ]
df_test[df_test$campaign>5,'Class']<-FALSE
df_test$campaign[df_test$campaign>5]<-5
df_test[,campaign2 := ifelse(campaign == 2, 1,0)]
df_test[,campaign3 := ifelse(campaign == 3, 1,0)]
df_test[,campaign4 := ifelse(campaign == 4, 1,0)]
df_test[,campaign5 := ifelse(campaign == 5, 1,0)]
# Work on training data
full_df <- df_train[rep(1:.N,campaign)][,campaign_no:=1:.N,by=ID]
full_df[campaign != campaign_no,'Class'] <- FALSE
full_df[,campaign2 := ifelse(campaign_no == 2, 1,0)]
full_df[,campaign3 := ifelse(campaign_no == 3, 1,0)]
full_df[,campaign4 := ifelse(campaign_no == 4, 1,0)]
full_df[,campaign5 := ifelse(campaign_no == 5, 1,0)]
model_df<-full_df[campaign_no<=5,c(56,1:30,47:49, 59:62)]
x_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5-1,data=model_df)
# foldid=sample(1:10,size=length(model_df$Class),replace=TRUE)
# cv_ridge <- cv.glmnet(x=x_matrix, y=model_df$Class, foldid=foldid, lambda = exp(seq(from = -10, to = 0, by = .1)), family="binomial",alpha=0)
# cv_enet <- cv.glmnet(x=x_matrix, y=model_df$Class, foldid=foldid, lambda = exp(seq(from = -10, to = 0, by = .1)), family="binomial",alpha=.5)
# cv_lasso <- cv.glmnet(x=x_matrix, y=model_df$Class, foldid=foldid, lambda = exp(seq(from = -10, to = 0, by = .1)), family="binomial",alpha=1)
#
# save(cv_ridge, file="cv_ridge.rda")
# save(cv_lasso, file="cv_lasso.rda")
# save(cv_enet, file="cv_enet.rda")
load(file="cv_ridge.rda")
load(file="cv_lasso.rda")
load(file="cv_enet.rda")
plot(log(cv_lasso$lambda),cv_lasso$cvm,pch=19,col="red",xlab="log(Lambda)",ylab=cv_lasso$name)
points(log(cv_enet$lambda),cv_enet$cvm,pch=19,col="grey")
points(log(cv_ridge$lambda),cv_ridge$cvm,pch=19,col="blue")
legend("topleft",legend=c("alpha= 1","alpha= .5","alpha 0"),pch=19,col=c("red","grey","blue"))
# test_reg   <-glm(Class~(age+jobadmin.+jobbluecollar+jobentrepreneur+jobhousemaid+jobmanagement+jobretired+jobselfemployed+jobservices+jobstudent+jobtechnician+jobunemployed+jobunknown) *( campaign2+campaign3)+campaign4+campaign5+maritalsingle+maritalunknown+educationbasic.6y+educationbasic.9y+educationhigh.school+educationilliterate+educationprofessional.course+educationuniversity.degree+educationunknown+defaultunknown+defaultyes+housingunknown+housingyes+loanunknown+loanyes,family='binomial',data=model_df)
#ASSUMPTIONS:
wage <-12 #Estimate of hourly wage
fail_time <-mean(df$duration[df$Class=="FALSE"]) / 3600
success_time <-mean(df$duration[df$Class=="TRUE"]) / 3600
Inter_call_time <-1/60
fail_cost<-wage*(fail_time+Inter_call_time)
success_cost <-wage*(success_time+Inter_call_time)
#Output: [cost of failure], [cost of success/signup]
#Profit from successful customer: According to a paper, CD rates in the Netherlands average ~60% of Euribor rates (https://onlinelibrary.wiley.com/doi/full/10.1111/irfi.12143)
Market_rate <-.025
CD_rate <-Market_rate*.6
Balance<-10000 #(simply assumed)
Term <- .25 #(.25 years, assumed based on rate)
Revenue <- Balance*Term*(Market_rate-CD_rate)  #(roughly a function of not having to borrow this money at market rates, flat curve assumed)
Success_profit <-Revenue - success_cost
#Generate estimates of cost per call, benefit (revenue/profit) of time deposit product for bank
#Cost- Relevant inputs: hourly wage, average call information (separate averages for failures and successes          b/c they have drastically different lengths)
Compute_Sample_Profitability<-function(obs){
sample_person <-df_test[obs]
#from regression coefficients + person's info: Simple prediction of success likelihood on the nth call "prob(n)" (conditional on failures for all previous calls)
#Loops through prediction turning on campaigns to calculate probabilities of success on calls 1:5
prob <-rep(NA,5)
sample_person$campaign2<-0
sample_person$campaign3<-0
sample_person$campaign4<-0
sample_person$campaign5<-0
prob[1] <-log_prob(predict(test_reg,sample_person))
sample_person$campaign2<-1
prob[2] <-log_prob(predict(test_reg,sample_person))
sample_person$campaign2<-0
sample_person$campaign3<-1
prob[3] <-log_prob(predict(test_reg,sample_person))
sample_person$campaign3<-0
sample_person$campaign4<-1
prob[4] <-log_prob(predict(test_reg,sample_person))
sample_person$campaign4<-0
sample_person$campaign5<-1
prob[5] <-log_prob(predict(test_reg,sample_person))
sample_person$campaign5<-0
#For Calls 1 through N, compute likelihood of success by the nth call: p_sub(n)
p_sub<-rep(NA,5)
p_sub[1]<-prob[1]
for (i in 2:5) {
p_sub[i] <-p_sub[i-1]+prob[i]*(1-p_sub[i-1])
}
#For calls 1 through N, compute lift of call n: lift(n)= p_sub(n) - p_sub(n-1) (this represents unconditional probability of success on call n)
lift<-rep(NA,5)
lift[1]<-p_sub[1]
for (i in 2:5) {
lift[i] <-p_sub[i]-p_sub[i-1]
}
#Compute number of calls to target for a given customer (N.B.: As long as probability of success is declining monotonically, as soon as the nth call is not profitable, the (n+1)th call will also not be profitable.)
#Test: Identify whether the nth call (if made) would be profitable. THis is simple:
#Profit(n|All calls prior="no")=[Profit of Success]*p_sub(n) -[Cost of Failure]*(1-p_sub(n))
Profit <- rep(NA,5)
for (i in 1:5){
Profit[i] <- Success_profit*prob[i]-fail_cost*(1-prob[i])
}
#Decision: for the first unprofitable call "A," choose  A-1 as the target number of calls.
Calls_to_make<-0
Calls_to_make <-NROW(Profit[Profit>0])
#based out this decision (target customer with A-1 calls), also compute
#(1) the expected number of calls with that rule(this is not simply A-1 b/c customer may sign up earlier), and
Expected_calls <- 0
if(Calls_to_make<=1) {
Expected_calls<-Calls_to_make
}  else {
for (i in 1:(Calls_to_make-1)){
Expected_calls<-Expected_calls+i*lift[i]
}
Expected_calls<-Expected_calls+Calls_to_make*(1-p_sub[Calls_to_make-1])
}
#(2) the expected profit from this strategy (weighted average of profitabilities forscenarios given this targeting plan, weighting each scenario by lift(n) and then adding together)
Expected_profit <- 0
if (Calls_to_make>0){
for (i in 1:Calls_to_make){
Expected_profit <-Expected_profit+lift[i]*(Success_profit-fail_cost*(i-1))
}
Expected_profit <-Expected_profit-fail_cost*Calls_to_make*(1-p_sub[Calls_to_make])
}
Metrics <-c("Euribor","Max Calls","Expected Calls", "Profit")
values<-c(Market_rate,Calls_to_make,Expected_calls,Expected_profit)
results <-data.frame(Metrics,values)
#  print(results)
return(Calls_to_make)
}
#Generate estimates of cost per call, benefit (revenue/profit) of time deposit product for bank
#Cost- Relevant inputs: hourly wage, average call information (separate averages for failures and successes          b/c they have drastically different lengths)
Compute_Sample_Profitability_LASSO<-function(obs,model){
sample_person <-df_test[obs]
#Loops through prediction turning on campaigns to calculate probabilities of success on calls 1:5
prob <-rep(NA,5)
sample_person$campaign2<-0
sample_person$campaign3<-0
sample_person$campaign4<-0
sample_person$campaign5<-0
lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5-1,data=lasso_test)
prob[1] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
sample_person$campaign2<-1
lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5-1,data=lasso_test)
prob[2] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
sample_person$campaign2<-0
sample_person$campaign3<-1
lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5-1,data=lasso_test)
prob[3] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
sample_person$campaign3<-0
sample_person$campaign4<-1
lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5-1,data=lasso_test)
prob[4] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
sample_person$campaign4<-0
sample_person$campaign5<-1
lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5-1,data=lasso_test)
prob[5] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
#For Calls 1 through N, compute likelihood of success by the nth call: p_sub(n)
p_sub<-rep(NA,5)
p_sub[1]<-prob[1]
for (i in 2:5) {
p_sub[i] <-p_sub[i-1]+prob[i]*(1-p_sub[i-1])
}
#For calls 1 through N, compute lift of call n: lift(n)= p_sub(n) - p_sub(n-1) (this represents unconditional probability of success on call n)
lift<-rep(NA,5)
lift[1]<-p_sub[1]
for (i in 2:5) {
lift[i] <-p_sub[i]-p_sub[i-1]
}
#Compute number of calls to target for a given customer (N.B.: As long as probability of success is declining monotonically, as soon as the nth call is not profitable, the (n+1)th call will also not be profitable.)
#Test: Identify whether the nth call (if made) would be profitable. THis is simple:
#Profit(n|All calls prior="no")=[Profit of Success]*p_sub(n) -[Cost of Failure]*(1-p_sub(n))
Profit <- rep(NA,5)
for (i in 1:5){
Profit[i] <- Success_profit*prob[i]-fail_cost*(1-prob[i])
}
#Decision: for the first unprofitable call "A," choose  A-1 as the target number of calls.
Calls_to_make<-0
Calls_to_make <-NROW(Profit[Profit>0])
#based out this decision (target customer with A-1 calls), also compute
#(1) the expected number of calls with that rule(this is not simply A-1 b/c customer may sign up earlier), and
Expected_calls <- 0
if(Calls_to_make<=1) {
Expected_calls<-Calls_to_make
}  else {
for (i in 1:(Calls_to_make-1)){
Expected_calls<-Expected_calls+i*lift[i]
}
Expected_calls<-Expected_calls+Calls_to_make*(1-p_sub[Calls_to_make-1])
}
#(2) the expected profit from this strategy (weighted average of profitabilities forscenarios given this targeting plan, weighting each scenario by lift(n) and then adding together)
Expected_profit <- 0
if (Calls_to_make>0){
for (i in 1:Calls_to_make){
Expected_profit <-Expected_profit+lift[i]*(Success_profit-fail_cost*(i-1))
}
Expected_profit <-Expected_profit-fail_cost*Calls_to_make*(1-p_sub[Calls_to_make])
}
Metrics <-c("Euribor","Max Calls","Expected Calls", "Profit")
values<-c(Market_rate,Calls_to_make,Expected_calls,Expected_profit)
results <-data.frame(Metrics,values)
#  print(results)
return_frame <- data.frame(max_calls = Calls_to_make, p1 = prob[1], p2 = prob[2], p3 = prob[3], p4 = prob[4], p5 = prob[5])
return(return_frame)
}
#Predict decisions (max calls to make) for test dataset using lasso
lasso_results <- data.frame(Max_calls_lasso = rep(0,nrow(df_test)), p1_lasso = rep(0,nrow(df_test)), p2_lasso = rep(0,nrow(df_test)), p3_lasso = rep(0,nrow(df_test)), p4_lasso = rep(0,nrow(df_test)), p5_lasso = rep(0,nrow(df_test)))
for (x in 1:nrow(df_test)) {
lasso_results[x,] <-Compute_Sample_Profitability_LASSO(x, cv_lasso)
}
df_test <- cbind(df_test,lasso_results)
hist(df_test$Max_calls_lasso)
nrow(df_test[df_test$Max_calls_lasso<df_test$campaign])/nrow(df_test)
#Predict decisions (max calls to make) for test dataset using ridge
enet_results <- data.frame(Max_calls_enet = rep(0,nrow(df_test)), p1_enet = rep(0,nrow(df_test)), p2_enet = rep(0,nrow(df_test)), p3_enet = rep(0,nrow(df_test)), p4_enet = rep(0,nrow(df_test)), p5_enet = rep(0,nrow(df_test)))
for (x in 1:nrow(df_test)) {
enet_results[x,] <-Compute_Sample_Profitability_LASSO(x, cv_enet)
}
df_test <- cbind(df_test,enet_results)
hist(df_test$Max_calls_enet)
nrow(df_test[df_test$Max_calls_enet<df_test$campaign])/nrow(df_test)
#Predict decisions (max calls to make) for test dataset using ridge
ridge_results <- data.frame(Max_calls_ridge = rep(0,nrow(df_test)), p1_ridge = rep(0,nrow(df_test)), p2_ridge = rep(0,nrow(df_test)), p3_ridge = rep(0,nrow(df_test)), p4_ridge = rep(0,nrow(df_test)), p5_ridge = rep(0,nrow(df_test)))
for (x in 1:nrow(df_test)) {
ridge_results[x,] <-Compute_Sample_Profitability_LASSO(x, cv_ridge)
}
df_test <- cbind(df_test,ridge_results)
hist(df_test$Max_calls_ridge)
df_tes
df_test
save(df_test,file='df_test.rda')
