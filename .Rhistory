}
#Decision: for the first unprofitable call "A," choose  A-1 as the target number of calls.
Calls_to_make<-0
Calls_to_make <-NROW(Profit[Profit>0])
#based out this decision (target customer with A-1 calls), also compute
#(1) the expected number of calls with that rule(this is not simply A-1 b/c customer may sign up earlier), and
Expected_calls <- 0
if(Calls_to_make<=1) {
Expected_calls<-Calls_to_make
}  else {
for (i in 1:(Calls_to_make-1)){
Expected_calls<-Expected_calls+i*lift[i]
}
Expected_calls<-Expected_calls+Calls_to_make*(1-p_sub[Calls_to_make-1])
}
#(2) the expected profit from this strategy (weighted average of profitabilities forscenarios given this targeting plan, weighting each scenario by lift(n) and then adding together)
Expected_profit <- 0
if (Calls_to_make>0){
for (i in 1:Calls_to_make){
Expected_profit <-Expected_profit+lift[i]*(Success_profit-fail_cost*(i-1))
}
Expected_profit <-Expected_profit-fail_cost*Calls_to_make*(1-p_sub[Calls_to_make])
}
Metrics <-c("Euribor","Max Calls","Expected Calls", "Profit")
values<-c(Market_rate,Calls_to_make,Expected_calls,Expected_profit)
results <-data.frame(Metrics,values)
#  print(results)
return(Calls_to_make)
}
# #Predict decisions (max calls to make) for test dataset using lasso
#
# df_test$Max_calls_ridge<-0
#
# for (x in 1:nrow(df_test)) {
#   df_test$Max_calls_ridge[x] <-Compute_Sample_Profitability_LASSO(x, cv_ridge)
#   }
#
# hist(df_test$Max_calls_ridge)
# nrow(df_test[df_test$Max_calls_ridge<df_test$campaign])/nrow(df_test)
# #Predict decisions (max calls to make) for test dataset using lasso
#
# df_test$Max_calls_enet<-0
#
# for (x in 1:nrow(df_test)) {
#   df_test$Max_calls_enet[x] <-Compute_Sample_Profitability_LASSO(x, cv_enet)
#   }
#
# hist(df_test$Max_calls_enet)
# nrow(df_test[df_test$Max_calls_enet<df_test$campaign])/nrow(df_test)
# #Predict decisions (max calls to make) for test dataset using lasso
#
# df_test$Max_calls_lasso<-0
#
# for (x in 1:nrow(df_test)) {
#   df_test$Max_calls_lasso[x] <-Compute_Sample_Profitability_LASSO(x, cv_lasso)
#   }
#
# hist(df_test$Max_calls_lasso)
# nrow(df_test[df_test$Max_calls_lasso<df_test$campaign])/nrow(df_test)
# #make decision for logit (employment) model
# df_test$Max_calls_logit<-0
#
# suppressWarnings( for (x in 1:nrow(df_test)) {
#   df_test$Max_calls_logit[x] <-Compute_Sample_Profitability(x)
#   }
# )
# hist(df_test$Max_calls_logit)
# nrow(df_test[df_test$Max_calls_logit<df_test$campaign])/nrow(df_test)
# save(df_test,file='df_test.rda')
load(file='df_test.rda')
#compute profit of calling all (as called)
baseline_profit <-0
for (x in 1:nrow(df_test)) {
if(df_test$Class[x]=="FALSE") { baseline_profit<-baseline_profit-df_test$campaign[x]*fail_cost
} else { baseline_profit<-baseline_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
}
baseline_profit
#ridge profit
ridge_profit <-0
for (x in 1:nrow(df_test)) {
if  (df_test$campaign[x]>df_test$Max_calls_ridge[x]){
ridge_profit<-ridge_profit-df_test$Max_calls_ridge[x]*fail_cost
} else {
if(df_test$Class[x]=="FALSE"){
ridge_profit<-ridge_profit-df_test$campaign[x]*fail_cost
} else { ridge_profit<-ridge_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
}
}
ridge_profit
enet_profit <-0
for (x in 1:nrow(df_test)) {
if  (df_test$campaign[x]>df_test$Max_calls_enet[x]){
enet_profit<-enet_profit-df_test$Max_calls_enet[x]*fail_cost
} else {
if(df_test$Class[x]=="FALSE"){
enet_profit<-enet_profit-df_test$campaign[x]*fail_cost
} else { enet_profit<-enet_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
}
}
enet_profit
lasso_profit <-0
for (x in 1:nrow(df_test)) {
if  (df_test$campaign[x]>df_test$Max_calls_lasso[x]){
lasso_profit<-lasso_profit-df_test$Max_calls_lasso[x]*fail_cost
} else {
if(df_test$Class[x]=="FALSE"){
lasso_profit<-lasso_profit-df_test$campaign[x]*fail_cost
} else { lasso_profit<-lasso_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
}
}
lasso_profit
#compute "theoretical best profit" ->targeting only people who say yes
best_profit <-0
for (x in 1:nrow(df_test)) {
if(df_test$Class[x]=="TRUE"){
best_profit<-best_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost
}
}
NROW(df_test[df_test$Class=="TRUE"])
best_profit
#logit profit
logit_profit <-0
for (x in 1:nrow(df_test)) {
if  (df_test$campaign[x]>df_test$Max_calls_logit[x]){
logit_profit<-logit_profit-df_test$Max_calls_logit[x]*fail_cost
} else {
if(df_test$Class[x]=="FALSE"){
logit_profit<-logit_profit-df_test$campaign[x]*fail_cost
} else { logit_profit<-logit_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
}
}
logit_profit
#Gains
lasso_profit/baseline_profit-1
three_call_profit <-0
for (x in 1:nrow(df_test)) {
if  (df_test$campaign[x]>3){
three_call_profit<-three_call_profit-3*fail_cost
} else {
if(df_test$Class[x]=="FALSE"){
three_call_profit<-three_call_profit-df_test$campaign[x]*fail_cost
} else { three_call_profit<-three_call_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
}
}
two_call_profit <-0
for (x in 1:nrow(df_test)) {
if  (df_test$campaign[x]>2){
two_call_profit<-two_call_profit-2*fail_cost
} else {
if(df_test$Class[x]=="FALSE"){
two_call_profit<-two_call_profit-df_test$campaign[x]*fail_cost
} else { two_call_profit<-two_call_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
}
}
barplot(c(baseline_profit,two_call_profit,three_call_profit,logit_profit,lasso_profit, enet_profit,ridge_profit), names = c("baseline","two-call","three-call","logit","lasso","enet","ridge"),ylim=c(0,12000))
#text(x=1:5,y=c(baseline_profit,two_call_profit,three_call_profit,logit_profit,lasso_profit)+300,labels = c(baseline_profit,two_call_profit,three_call_profit,logit_profit,lasso_profit))
barplot(c(baseline_profit,two_call_profit,three_call_profit,logit_profit,lasso_profit, enet_profit,ridge_profit, best_profit), names = c("baseline","two-call","three-call","logit","lasso","enet","ridge","max profit"),ylim=c(0,22000))
knitr::opts_chunk$set(echo = TRUE)
library(caret)
library(data.table)
library(glmnet)
library(rpart)
library(rpart.plot)
library(randomForest)
library(xgboost)
library(gbm)
library(class)
library(pvclass)
library(knnGarden)
log_prob <- function(pred){
1/(1+exp(-pred))
}
df <- read.csv("bank_additional_full.csv")
levels(df$job)[2] <- "bluecollar"
levels(df$job)[7] <- "selfemployed"
df <- as.data.table(model.matrix(~.-1,df))
# colnames(df)[colnames(df)=="ytrue"] <- "outcome"
df$Class <- ifelse(df$ytrue==1,TRUE,FALSE)
#
# summary(df)
# str(df)
# table(df$campaign)
#
# barplot(table(df$Class,df$campaign)[2,1:15]/(table(df$Class,df$campaign)[1,1:15]+table(df$Class,df$campaign)[2,1:15]))
summary(df$Class)
NROW(df$Class[df$Class=='TRUE'])/NROW(df$Class)
df[,ID := .I]
#split into test and train
set.seed(99)
training_size <- floor(0.80 * nrow(df))
train_ind <- sample(seq_len(nrow(df)), size = training_size)
df_train <- df[train_ind, ]
df_test <- df[-train_ind, ]
df_test[df_test$campaign>5,'Class']<-FALSE
df_test$campaign[df_test$campaign>5]<-5
df_test[,campaign2 := ifelse(campaign == 2, 1,0)]
df_test[,campaign3 := ifelse(campaign == 3, 1,0)]
df_test[,campaign4 := ifelse(campaign == 4, 1,0)]
df_test[,campaign5 := ifelse(campaign == 5, 1,0)]
# Work on training data
full_df <- df_train[rep(1:.N,campaign)][,campaign_no:=1:.N,by=ID]
full_df[campaign != campaign_no,'Class'] <- FALSE
full_df[,campaign2 := ifelse(campaign_no == 2, 1,0)]
full_df[,campaign3 := ifelse(campaign_no == 3, 1,0)]
full_df[,campaign4 := ifelse(campaign_no == 4, 1,0)]
full_df[,campaign5 := ifelse(campaign_no == 5, 1,0)]
model_df<-full_df[campaign_no<=5,c(56,1:30,47:49, 59:62)]
x_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5-1,data=model_df)
foldid=sample(1:10,size=length(model_df$Class),replace=TRUE)
cv_ridge <- cv.glmnet(x=x_matrix, y=model_df$Class, foldid=foldid, lambda = exp(seq(from = -10, to = 0, by = .1)), family="binomial",alpha=0)
cv_enet <- cv.glmnet(x=x_matrix, y=model_df$Class, foldid=foldid, lambda = exp(seq(from = -10, to = 0, by = .1)), family="binomial",alpha=.5)
cv_lasso <- cv.glmnet(x=x_matrix, y=model_df$Class, foldid=foldid, lambda = exp(seq(from = -10, to = 0, by = .1)), family="binomial",alpha=1)
save(cv_ridge, file="cv_ridge.rda")
save(cv_lasso, file="cv_lasso.rda")
save(cv_enet, file="cv_enet.rda")
# load(file="cv_ridge.rda")
# load(file="cv_lasso.rda")
# load(file="cv_enet.rda")
plot(log(cv_lasso$lambda),cv_lasso$cvm,pch=19,col="red",xlab="log(Lambda)",ylab=cv_lasso$name)
points(log(cv_enet$lambda),cv_enet$cvm,pch=19,col="grey")
points(log(cv_ridge$lambda),cv_ridge$cvm,pch=19,col="blue")
legend("topleft",legend=c("alpha= 1","alpha= .5","alpha 0"),pch=19,col=c("red","grey","blue"))
# test_reg   <-glm(Class~(age+jobadmin.+jobbluecollar+jobentrepreneur+jobhousemaid+jobmanagement+jobretired+jobselfemployed+jobservices+jobstudent+jobtechnician+jobunemployed+jobunknown) *( campaign2+campaign3)+campaign4+campaign5+maritalsingle+maritalunknown+educationbasic.6y+educationbasic.9y+educationhigh.school+educationilliterate+educationprofessional.course+educationuniversity.degree+educationunknown+defaultunknown+defaultyes+housingunknown+housingyes+loanunknown+loanyes,family='binomial',data=model_df)
#ASSUMPTIONS:
wage <-12 #Estimate of hourly wage
fail_time <-mean(df$duration[df$Class=="FALSE"]) / 3600
success_time <-mean(df$duration[df$Class=="TRUE"]) / 3600
Inter_call_time <-1/60
fail_cost<-wage*(fail_time+Inter_call_time)
success_cost <-wage*(success_time+Inter_call_time)
#Output: [cost of failure], [cost of success/signup]
#Profit from successful customer: According to a paper, CD rates in the Netherlands average ~60% of Euribor rates (https://onlinelibrary.wiley.com/doi/full/10.1111/irfi.12143)
Market_rate <-.025
CD_rate <-Market_rate*.6
Balance<-10000 #(simply assumed)
Term <- .25 #(.25 years, assumed based on rate)
Revenue <- Balance*Term*(Market_rate-CD_rate)  #(roughly a function of not having to borrow this money at market rates, flat curve assumed)
Success_profit <-Revenue - success_cost
#Generate estimates of cost per call, benefit (revenue/profit) of time deposit product for bank
#Cost- Relevant inputs: hourly wage, average call information (separate averages for failures and successes          b/c they have drastically different lengths)
Compute_Sample_Profitability<-function(obs){
sample_person <-df_test[obs]
#from regression coefficients + person's info: Simple prediction of success likelihood on the nth call "prob(n)" (conditional on failures for all previous calls)
#Loops through prediction turning on campaigns to calculate probabilities of success on calls 1:5
prob <-rep(NA,5)
sample_person$campaign2<-0
sample_person$campaign3<-0
sample_person$campaign4<-0
sample_person$campaign5<-0
prob[1] <-log_prob(predict(test_reg,sample_person))
sample_person$campaign2<-1
prob[2] <-log_prob(predict(test_reg,sample_person))
sample_person$campaign2<-0
sample_person$campaign3<-1
prob[3] <-log_prob(predict(test_reg,sample_person))
sample_person$campaign3<-0
sample_person$campaign4<-1
prob[4] <-log_prob(predict(test_reg,sample_person))
sample_person$campaign4<-0
sample_person$campaign5<-1
prob[5] <-log_prob(predict(test_reg,sample_person))
sample_person$campaign5<-0
#For Calls 1 through N, compute likelihood of success by the nth call: p_sub(n)
p_sub<-rep(NA,5)
p_sub[1]<-prob[1]
for (i in 2:5) {
p_sub[i] <-p_sub[i-1]+prob[i]*(1-p_sub[i-1])
}
#For calls 1 through N, compute lift of call n: lift(n)= p_sub(n) - p_sub(n-1) (this represents unconditional probability of success on call n)
lift<-rep(NA,5)
lift[1]<-p_sub[1]
for (i in 2:5) {
lift[i] <-p_sub[i]-p_sub[i-1]
}
#Compute number of calls to target for a given customer (N.B.: As long as probability of success is declining monotonically, as soon as the nth call is not profitable, the (n+1)th call will also not be profitable.)
#Test: Identify whether the nth call (if made) would be profitable. THis is simple:
#Profit(n|All calls prior="no")=[Profit of Success]*p_sub(n) -[Cost of Failure]*(1-p_sub(n))
Profit <- rep(NA,5)
for (i in 1:5){
Profit[i] <- Success_profit*prob[i]-fail_cost*(1-prob[i])
}
#Decision: for the first unprofitable call "A," choose  A-1 as the target number of calls.
Calls_to_make<-0
Calls_to_make <-NROW(Profit[Profit>0])
#based out this decision (target customer with A-1 calls), also compute
#(1) the expected number of calls with that rule(this is not simply A-1 b/c customer may sign up earlier), and
Expected_calls <- 0
if(Calls_to_make<=1) {
Expected_calls<-Calls_to_make
}  else {
for (i in 1:(Calls_to_make-1)){
Expected_calls<-Expected_calls+i*lift[i]
}
Expected_calls<-Expected_calls+Calls_to_make*(1-p_sub[Calls_to_make-1])
}
#(2) the expected profit from this strategy (weighted average of profitabilities forscenarios given this targeting plan, weighting each scenario by lift(n) and then adding together)
Expected_profit <- 0
if (Calls_to_make>0){
for (i in 1:Calls_to_make){
Expected_profit <-Expected_profit+lift[i]*(Success_profit-fail_cost*(i-1))
}
Expected_profit <-Expected_profit-fail_cost*Calls_to_make*(1-p_sub[Calls_to_make])
}
Metrics <-c("Euribor","Max Calls","Expected Calls", "Profit")
values<-c(Market_rate,Calls_to_make,Expected_calls,Expected_profit)
results <-data.frame(Metrics,values)
#  print(results)
return(Calls_to_make)
}
#Generate estimates of cost per call, benefit (revenue/profit) of time deposit product for bank
#Cost- Relevant inputs: hourly wage, average call information (separate averages for failures and successes          b/c they have drastically different lengths)
Compute_Sample_Profitability_LASSO<-function(obs,model){
sample_person <-df_test[obs]
#Loops through prediction turning on campaigns to calculate probabilities of success on calls 1:5
prob <-rep(NA,5)
sample_person$campaign2<-0
sample_person$campaign3<-0
sample_person$campaign4<-0
sample_person$campaign5<-0
lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5-1,data=lasso_test)
prob[1] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
sample_person$campaign2<-1
lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5-1,data=lasso_test)
prob[2] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
sample_person$campaign2<-0
sample_person$campaign3<-1
lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5-1,data=lasso_test)
prob[3] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
sample_person$campaign3<-0
sample_person$campaign4<-1
lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5-1,data=lasso_test)
prob[4] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
sample_person$campaign4<-0
sample_person$campaign5<-1
lasso_test<-sample_person[,c(56,1:30,47:49, 58:61)]
test_matrix <- model.matrix(Class~.*(campaign2+campaign3+campaign4+campaign5)-campaign2*(campaign3+campaign4+campaign5)-campaign3*(campaign4+campaign5)-campaign4*campaign5-1,data=lasso_test)
prob[5] <-log_prob(predict(model,newx=test_matrix,s=model$lambda.min))
#For Calls 1 through N, compute likelihood of success by the nth call: p_sub(n)
p_sub<-rep(NA,5)
p_sub[1]<-prob[1]
for (i in 2:5) {
p_sub[i] <-p_sub[i-1]+prob[i]*(1-p_sub[i-1])
}
#For calls 1 through N, compute lift of call n: lift(n)= p_sub(n) - p_sub(n-1) (this represents unconditional probability of success on call n)
lift<-rep(NA,5)
lift[1]<-p_sub[1]
for (i in 2:5) {
lift[i] <-p_sub[i]-p_sub[i-1]
}
#Compute number of calls to target for a given customer (N.B.: As long as probability of success is declining monotonically, as soon as the nth call is not profitable, the (n+1)th call will also not be profitable.)
#Test: Identify whether the nth call (if made) would be profitable. THis is simple:
#Profit(n|All calls prior="no")=[Profit of Success]*p_sub(n) -[Cost of Failure]*(1-p_sub(n))
Profit <- rep(NA,5)
for (i in 1:5){
Profit[i] <- Success_profit*prob[i]-fail_cost*(1-prob[i])
}
#Decision: for the first unprofitable call "A," choose  A-1 as the target number of calls.
Calls_to_make<-0
Calls_to_make <-NROW(Profit[Profit>0])
#based out this decision (target customer with A-1 calls), also compute
#(1) the expected number of calls with that rule(this is not simply A-1 b/c customer may sign up earlier), and
Expected_calls <- 0
if(Calls_to_make<=1) {
Expected_calls<-Calls_to_make
}  else {
for (i in 1:(Calls_to_make-1)){
Expected_calls<-Expected_calls+i*lift[i]
}
Expected_calls<-Expected_calls+Calls_to_make*(1-p_sub[Calls_to_make-1])
}
#(2) the expected profit from this strategy (weighted average of profitabilities forscenarios given this targeting plan, weighting each scenario by lift(n) and then adding together)
Expected_profit <- 0
if (Calls_to_make>0){
for (i in 1:Calls_to_make){
Expected_profit <-Expected_profit+lift[i]*(Success_profit-fail_cost*(i-1))
}
Expected_profit <-Expected_profit-fail_cost*Calls_to_make*(1-p_sub[Calls_to_make])
}
Metrics <-c("Euribor","Max Calls","Expected Calls", "Profit")
values<-c(Market_rate,Calls_to_make,Expected_calls,Expected_profit)
results <-data.frame(Metrics,values)
#  print(results)
return(Calls_to_make)
}
#Predict decisions (max calls to make) for test dataset using lasso
df_test$Max_calls_ridge<-0
for (x in 1:nrow(df_test)) {
df_test$Max_calls_ridge[x] <-Compute_Sample_Profitability_LASSO(x, cv_ridge)
}
hist(df_test$Max_calls_ridge)
nrow(df_test[df_test$Max_calls_ridge<df_test$campaign])/nrow(df_test)
#Predict decisions (max calls to make) for test dataset using lasso
df_test$Max_calls_enet<-0
for (x in 1:nrow(df_test)) {
df_test$Max_calls_enet[x] <-Compute_Sample_Profitability_LASSO(x, cv_enet)
}
hist(df_test$Max_calls_enet)
nrow(df_test[df_test$Max_calls_enet<df_test$campaign])/nrow(df_test)
#Predict decisions (max calls to make) for test dataset using lasso
df_test$Max_calls_lasso<-0
for (x in 1:nrow(df_test)) {
df_test$Max_calls_lasso[x] <-Compute_Sample_Profitability_LASSO(x, cv_lasso)
}
hist(df_test$Max_calls_lasso)
nrow(df_test[df_test$Max_calls_lasso<df_test$campaign])/nrow(df_test)
#make decision for logit (employment) model
df_test$Max_calls_logit<-0
suppressWarnings( for (x in 1:nrow(df_test)) {
df_test$Max_calls_logit[x] <-Compute_Sample_Profitability(x)
}
)
test_reg   <-glm(Class~(age+jobadmin.+jobbluecollar+jobentrepreneur+jobhousemaid+jobmanagement+jobretired+jobselfemployed+jobservices+jobstudent+jobtechnician+jobunemployed+jobunknown) *( campaign2+campaign3)+campaign4+campaign5+maritalsingle+maritalunknown+educationbasic.6y+educationbasic.9y+educationhigh.school+educationilliterate+educationprofessional.course+educationuniversity.degree+educationunknown+defaultunknown+defaultyes+housingunknown+housingyes+loanunknown+loanyes,family='binomial',data=model_df)
#make decision for logit (employment) model
df_test$Max_calls_logit<-0
suppressWarnings( for (x in 1:nrow(df_test)) {
df_test$Max_calls_logit[x] <-Compute_Sample_Profitability(x)
}
)
hist(df_test$Max_calls_logit)
nrow(df_test[df_test$Max_calls_logit<df_test$campaign])/nrow(df_test)
save(df_test,file='df_test.rda')
# load(file='df_test.rda')
#compute profit of calling all (as called)
baseline_profit <-0
for (x in 1:nrow(df_test)) {
if(df_test$Class[x]=="FALSE") { baseline_profit<-baseline_profit-df_test$campaign[x]*fail_cost
} else { baseline_profit<-baseline_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
}
baseline_profit
#ridge profit
ridge_profit <-0
for (x in 1:nrow(df_test)) {
if  (df_test$campaign[x]>df_test$Max_calls_ridge[x]){
ridge_profit<-ridge_profit-df_test$Max_calls_ridge[x]*fail_cost
} else {
if(df_test$Class[x]=="FALSE"){
ridge_profit<-ridge_profit-df_test$campaign[x]*fail_cost
} else { ridge_profit<-ridge_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
}
}
ridge_profit
enet_profit <-0
for (x in 1:nrow(df_test)) {
if  (df_test$campaign[x]>df_test$Max_calls_enet[x]){
enet_profit<-enet_profit-df_test$Max_calls_enet[x]*fail_cost
} else {
if(df_test$Class[x]=="FALSE"){
enet_profit<-enet_profit-df_test$campaign[x]*fail_cost
} else { enet_profit<-enet_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
}
}
enet_profit
lasso_profit <-0
for (x in 1:nrow(df_test)) {
if  (df_test$campaign[x]>df_test$Max_calls_lasso[x]){
lasso_profit<-lasso_profit-df_test$Max_calls_lasso[x]*fail_cost
} else {
if(df_test$Class[x]=="FALSE"){
lasso_profit<-lasso_profit-df_test$campaign[x]*fail_cost
} else { lasso_profit<-lasso_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
}
}
lasso_profit
#compute "theoretical best profit" ->targeting only people who say yes
best_profit <-0
for (x in 1:nrow(df_test)) {
if(df_test$Class[x]=="TRUE"){
best_profit<-best_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost
}
}
NROW(df_test[df_test$Class=="TRUE"])
best_profit
#logit profit
logit_profit <-0
for (x in 1:nrow(df_test)) {
if  (df_test$campaign[x]>df_test$Max_calls_logit[x]){
logit_profit<-logit_profit-df_test$Max_calls_logit[x]*fail_cost
} else {
if(df_test$Class[x]=="FALSE"){
logit_profit<-logit_profit-df_test$campaign[x]*fail_cost
} else { logit_profit<-logit_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
}
}
logit_profit
#Gains
lasso_profit/baseline_profit-1
three_call_profit <-0
for (x in 1:nrow(df_test)) {
if  (df_test$campaign[x]>3){
three_call_profit<-three_call_profit-3*fail_cost
} else {
if(df_test$Class[x]=="FALSE"){
three_call_profit<-three_call_profit-df_test$campaign[x]*fail_cost
} else { three_call_profit<-three_call_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
}
}
two_call_profit <-0
for (x in 1:nrow(df_test)) {
if  (df_test$campaign[x]>2){
two_call_profit<-two_call_profit-2*fail_cost
} else {
if(df_test$Class[x]=="FALSE"){
two_call_profit<-two_call_profit-df_test$campaign[x]*fail_cost
} else { two_call_profit<-two_call_profit+Success_profit-(df_test$campaign[x]-1)*fail_cost}
}
}
barplot(c(baseline_profit,two_call_profit,three_call_profit,logit_profit,lasso_profit, enet_profit,ridge_profit, best_profit), names = c("baseline","two-call","three-call","logit","lasso","enet","ridge","max profit"),ylim=c(0,22000))
#text(x=1:5,y=c(baseline_profit,two_call_profit,three_call_profit,logit_profit,lasso_profit)+300,labels = c(baseline_profit,two_call_profit,three_call_profit,logit_profit,lasso_profit))
